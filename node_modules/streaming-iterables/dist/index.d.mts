declare module 'streaming-iterables' {
  export type UnwrapAnyIterableArray<M extends AnyIterable<any>> = M extends Iterable<infer T> ? Generator<T[]> : M extends AsyncIterable<infer B> ? AsyncGenerator<B[]> : never;
  export type CurriedBatchResult = <T, M extends AnyIterable<T>>(curriedIterable: M) => UnwrapAnyIterableArray<M>;
  /**
   * Batch objects from `iterable` into arrays of `size` length. The final array may be shorter than size if there is not enough items. Returns a sync iterator if the `iterable` is sync, otherwise an async iterator. Errors from the source `iterable` are immediately raised.

  `size` can be between 1 and `Infinity`.

  ```ts
  import { batch } from 'streaming-iterables'
  import { getPokemon } from 'iterable-pokedex'

  // batch 10 pokemon while we process them
  for await (const pokemons of batch(10, getPokemon())) {
	console.log(pokemons) // 10 pokemon at a time!
  }
  ```
   */
  export function batch(size: number): CurriedBatchResult;
  export function batch<T, M extends AnyIterable<T>>(size: number, iterable: M): UnwrapAnyIterableArray<M>;
  export type CurriedBatchWithTimeoutResult = <T, M extends AnyIterable<T>>(curriedIterable: M) => UnwrapAnyIterableArray<M>;
  /**
   * Like `batch` but flushes early if the `timeout` is reached. The batches may be shorter than size if there are not enough items. Returns a sync iterator if the `iterable` is sync, otherwise an async iterator. Errors from the source `iterable` are immediately raised.

  `size` can be between 1 and `Infinity`.
  `timeout` can be between 0 and `Infinity`.

  ```ts
  import { batchWithTimeout } from 'streaming-iterables'
  import { getPokemon } from 'iterable-pokedex'

  // batch 10 pokemon while we process them
  for await (const pokemons of batchWithTimeout(10, 100, getPokemon())) {
	console.log(pokemons) // Up to 10 pokemon at a time!
  }
  ```
   */
  export function batchWithTimeout(size: number, timeout: number): CurriedBatchWithTimeoutResult;
  export function batchWithTimeout<T, M extends AnyIterable<T>>(size: number, timeout: number, iterable: M): UnwrapAnyIterableArray<M>;
  export type CurriedBufferResult = <T, M extends AnyIterable<T>>(curriedIterable: M) => UnwrapAnyIterable<M>;
  /**
   * Buffer keeps a number of objects in reserve available for immediate reading. This is helpful with async iterators as it will pre-fetch results so you don't have to wait for them to load. For sync iterables it will pre-compute up to `size` values and keep them in reserve. The internal buffer will start to be filled once `.next()` is called for the first time and will continue to fill until the source `iterable` is exhausted or the buffer is full. Errors from the source `iterable` will be raised after all buffered values are yielded.

  `size` can be between 0 and `Infinity`.

  ```ts
  import { buffer } from 'streaming-iterables'
  import { getPokemon, trainMonster } from 'iterable-pokedex'

  // load 10 monsters in the background while we process them one by one
  for await (const monster of buffer(10, getPokemon())) {
	await trainMonster(monster) // got to do some pok√©work
  }
  ```
   */
  export function buffer(size: number): CurriedBufferResult;
  export function buffer<T, M extends AnyIterable<T>>(size: number, iterable: M): UnwrapAnyIterable<M>;
	export type UnwrapToPromiseOrAsyncIterable<M extends AnyIterable<any>> = M extends Iterable<infer T> ? T[] : M extends AsyncIterable<infer B> ? Promise<B[]> : never;
	/**
	 * Collect all the values from an iterable into an array. Returns an array if you pass it an iterable and a promise for an array if you pass it an async iterable. Errors from the source `iterable` are raised immediately.

	```ts
	import { collect } from 'streaming-iterables'
	import { getPokemon } from 'iterable-pokedex'

	console.log(await collect(getPokemon()))
	// [bulbasaur, ivysaur, venusaur, charmander, ...]
	```
	 */
	export function collect<T, M extends AnyIterable<T>>(iterable: M): UnwrapToPromiseOrAsyncIterable<M>;
  /**
   * Combine multiple iterators into a single iterable. Reads each iterable completely one at a time. Returns a sync iterator if all `iterables` are sync, otherwise it returns an async iterable. Errors from the source `iterable` are raised immediately.

  ```ts
  import { concat } from 'streaming-iterables'
  import { getPokemon } from 'iterable-pokedex'
  import { getTransformers } from './util'

  for await (const hero of concat(getPokemon(2), getTransformers(2))) {
	console.log(hero)
  }
  // charmander
  // bulbasaur <- end of pokemon
  // megatron
  // bumblebee <- end of transformers
  ```
   */
  export function concat<I extends Iterable<any>[]>(...iterables: I): Iterable<UnArrayAnyIterable<I>>;
  export function concat<I extends AnyIterable<any>[]>(...iterables: I): AsyncIterable<UnArrayAnyIterable<I>>;
	/**
	 * A promise that resolves after the function drains the iterable of all data. Useful for processing a pipeline of data. Errors from the source `iterable` are raised immediately.

	```ts
	import { consume, map } from 'streaming-iterables'
	import { getPokemon, trainMonster } from 'iterable-pokedex'

	const train = map(trainMonster)
	await consume(train(getPokemon())) // load all the pokemon and train them!
	```
	 */
	export function consume<T>(iterable: Iterable<T>): void;
	export function consume<T>(iterable: AsyncIterable<T>): Promise<void>;
	export type CurriedDropResult = <T, M extends AnyIterable<T>>(curriedIterable: M) => UnwrapAnyIterable<M>;
	/**
	 * Returns a new iterator that skips a specific number of items from `iterable`. When used with generators it advances the generator `count` items, when used with arrays it gets a new iterator and skips `count` items.

	```ts
	import { pipeline, drop, collect } from 'streaming-iterables'
	import { getPokemon } from 'iterable-pokedex'

	const allButFirstFive = await collect(drop(5, getPokemon()))
	// first five pokemon
	```
	 */
	export function drop(count: number): CurriedDropResult;
	export function drop<T, M extends AnyIterable<T>>(count: number, iterable: M): UnwrapAnyIterable<M>;
  /**
   * Takes a `filterFunc` and a `iterable`, and returns a new async iterator of the same type containing the members of the given iterable which cause the `filterFunc` to return true.

  ```ts
  import { filter } from 'streaming-iterables'
  import { getPokemon } from 'iterable-pokedex'

  const filterWater = filter(pokemon => pokemon.types.include('Water'))

  for await (const pokemon of filterWater(getPokemon())) {
	console.log(pokemon)
  }
  // squirtle
  // vaporeon
  // magikarp
  ```
   */
  export function filter<T, S extends T>(filterFunc: (data: T) => data is S): <A extends T>(curriedIterable: AnyIterable<A>) => AsyncGenerator<S>;
  export function filter<T>(filterFunc: (data: T) => boolean | Promise<boolean>): <A>(curriedIterable: AnyIterable<A>) => AsyncGenerator<A>;
  export function filter<T, S extends T>(filterFunc: (data: T) => data is S, iterable: AnyIterable<T>): AsyncGenerator<S>;
  export function filter<T>(filterFunc: (data: T) => boolean | Promise<boolean>, iterable: AnyIterable<T>): AsyncGenerator<T>;
  /**
   * Map `func` over the `iterable`, flatten the result and then ignore all null or undefined values. It's the transform function we've always needed. It's equivalent to;

  ```ts
  (func, iterable) => filter(i => i !== undefined && i !== null, flatten(map(func, iterable)))
  ```

  *note*: The return value for `func` is `FlatMapValue<B>`. Typescript doesn't have recursive types but you can nest iterables as deep as you like.

  The ordering of the results is guaranteed. Errors from the source `iterable` are raised after all mapped values are yielded. Errors from `func` are raised after all previously mapped values are yielded.

  ```ts
  import { flatMap } from 'streaming-iterables'
  import { getPokemon, lookupStats } from 'iterable-pokedex'

  async function getDefeatedGyms(pokemon) {
	if (pokemon.gymBattlesWon > 0) {
	  const stats = await lookupStats(pokemon)
	  return stats.gyms
	}
  }

  for await (const gym of flatMap(getDefeatedGyms, getPokemon())) {
	console.log(gym.name)
  }
  // "Pewter Gym"
  // "Cerulean Gym"
  // "Vermilion Gym"
  ```
   */
  export function flatMap<T, B>(func: (data: T) => FlatMapValue<B>): (iterable: AnyIterable<T>) => AsyncGenerator<NonNullable<B>>;
  export function flatMap<T, B>(func: (data: T) => FlatMapValue<B>, iterable: AnyIterable<T>): AsyncGenerator<NonNullable<B>>;
  /**
   * Returns a new iterator by pulling every item out of `iterable` (and all its sub iterables) and yielding them depth-first. Checks for the iterable interfaces and iterates it if it exists. If the value is a string it is not iterated as that ends up in an infinite loop. Errors from the source `iterable` are raised immediately.

  *note*: Typescript doesn't have recursive types but you can nest iterables as deep as you like.

  ```ts
  import { flatten } from 'streaming-iterables'

  for await (const item of flatten([1, 2, [3, [4, 5], 6])) {
	console.log(item)
  }
  // 1
  // 2
  // 3
  // 4
  // 5
  // 6
  ```
   */
  export function flatten<B>(iterable: AnyIterable<B | AnyIterable<B>>): AsyncIterableIterator<B>;
  /**
   * Map `func` over the `iterable`, flatten the result and then ignore all null or undefined values. Returned async iterables are flattened concurrently too. It's the transform function we've always wanted.

  It's similar to;

  ```ts
  const filterEmpty = filter(i => i !== undefined && i !== null)
  (concurrency, func, iterable) => filterEmpty(flatten(transform(concurrency, func, iterable)))
  ```

  *note*: The return value for `func` is `FlatMapValue<B>`. Typescript doesn't have recursive types but you can nest iterables as deep as you like. However only directly returned async iterables are processed concurrently. (Eg, if you use an async generator function as `func` it's output will be processed concurrently, but if it's nested inside other iterables it will be processed sequentially.)

  Order is determined by when async operations resolve. And it will run up to `concurrency` async operations at once. This includes promises and async iterables returned from `func`. Errors from the source `iterable` are raised after all transformed values are yielded. Errors from `func` are raised after all previously transformed values are yielded.

  `concurrency` can be between 1 and `Infinity`.

  Promise Example;

  ```ts
  import { flatTransform } from 'streaming-iterables'
  import { getPokemon, lookupStats } from 'iterable-pokedex'

  async function getDefeatedGyms(pokemon) {
	if (pokemon.gymBattlesWon > 0) {
	  const stats = await lookupStats(pokemon)
	  return stats.gyms
	}
  }

  // lookup 10 stats at a time
  for await (const gym of flatTransform(10, getDefeatedGyms, getPokemon())) {
	console.log(gym.name)
  }
  // "Pewter Gym"
  // "Cerulean Gym"
  // "Vermilion Gym"
  ```

  Async Generator Example

  ```ts
  import { flatTransform } from 'streaming-iterables'
  import { getPokemon } from 'iterable-pokedex'
  import { findFriendsFB, findFriendsMySpace } from './util'


  async function* findFriends (pokemon) {
	yield await findFriendsFB(pokemon.name)
	yield await findFriendsMySpace(pokemon.name)
  }

  for await (const pokemon of flatTransform(10, findFriends, getPokemon())) {
	console.log(pokemon.name)
  }
  // Pikachu
  // Meowth
  // Ash - FB
  // Jessie - FB
  // Misty - MySpace
  // James - MySpace
  ```
   */
  export function flatTransform(concurrency: number): {
	  <T, R>(func: (data: T) => FlatMapValue<R>, iterable: AnyIterable<T>): AsyncGenerator<R>;
	  <T, R>(func: (data: T) => FlatMapValue<R>): (iterable: AnyIterable<T>) => AsyncGenerator<R>;
  };
  export function flatTransform<T, R>(concurrency: number, func: (data: T) => FlatMapValue<R>): (iterable: AnyIterable<T>) => AsyncGenerator<R>;
  export function flatTransform<T, R>(concurrency: number, func: (data: T) => FlatMapValue<R>, iterable: AnyIterable<T>): AsyncGenerator<R>;
  export interface ReadableStreamish {
	  once: any;
	  read: any;
  }
  /**
   * Wraps the stream in an async iterator or returns the stream if it already is an async iterator.

  *note*: Since Node 10, streams already async iterators. This function may be used to ensure compatibility with older versions of Node.

  ```ts
  import { fromStream } from 'streaming-iterables'
  import { createReadStream } from 'fs'

  const pokeLog = fromStream(createReadStream('./pokedex-operating-system.log'))

  for await (const pokeData of pokeLog) {
	console.log(pokeData) // Buffer(...)
  }
  ```
   * @deprecated This method is deprecated since, node 10 is out of LTS. It may be removed in an upcoming major release.
   */
  export function fromStream<T>(stream: ReadableStreamish): AsyncIterable<T>;
	/**
	 * Get the iterator from any iterable or just return an iterator itself.
	 */
	export function getIterator<T>(iterable: Iterable<T> | Iterator<T>): Iterator<T>;
	export function getIterator<T>(iterable: AsyncIterable<T> | AsyncIterator<T>): AsyncIterator<T>;
	export function getIterator<T>(iterable: AsyncIterable<T> | Iterable<T>): AsyncIterator<T> | Iterator<T>;
	/**
	 * Any iterable or iterator.
	 */
	export type Iterableish<T> = Iterable<T> | Iterator<T> | AsyncIterable<T> | AsyncIterator<T>;
	/**
	 * Literally any `Iterable` (async or regular).
	 */
	export type AnyIterable<T> = Iterable<T> | AsyncIterable<T>;
	/**
	 * A value, an array of that value, undefined, null or promises for any of them. Used in the `flatMap` and `flatTransform` functions as possible return values of the mapping function.
	 */
	export type FlatMapValue<B> = B | AnyIterable<B> | undefined | null | Promise<B | AnyIterable<B> | undefined | null>;
	export type UnArrayAnyIterable<A extends AnyIterable<any>[]> = A extends AnyIterable<infer T>[] ? T : never;
	export type UnwrapAnyIterable<M extends AnyIterable<any>> = M extends Iterable<infer T> ? Iterable<T> : M extends AsyncIterable<infer B> ? AsyncIterable<B> : never;
  /**
   * Map a function or async function over all the values of an iterable. Errors from the source `iterable` and `func` are raised immediately.

  ```ts
  import { consume, map } from 'streaming-iterables'
  import got from 'got'

  const urls = ['https://http.cat/200', 'https://http.cat/201', 'https://http.cat/202']
  const download = map(got)

  // download one at a time
  for await (page of download(urls)) {
	console.log(page)
  }
  ```
   */
  export function map<T, B>(func: (data: T) => B | Promise<B>): (iterable: AnyIterable<T>) => AsyncGenerator<B>;
  export function map<T, B>(func: (data: T) => B | Promise<B>, iterable: AnyIterable<T>): AsyncGenerator<B>;
	/**
	 * Combine multiple iterators into a single iterable. Reads one item off each iterable in order repeatedly until they are all exhausted. If you care less about order and want them faster see `parallelMerge()`.
	 */
	export function merge<I extends AnyIterable<any>[]>(...iterables: I): AsyncIterable<UnArrayAnyIterable<I>>;
	export function parallelFlatMap<T, R>(concurrency: number): {
		(func: (data: T) => R | Promise<R>, iterable: AnyIterable<T>): AsyncGenerator<R>;
		(func: (data: T) => R | Promise<R>): (iterable: AnyIterable<T>) => AsyncGenerator<R>;
	};
	export function parallelFlatMap<T, R>(concurrency: number, func: (data: T) => R | Promise<R>): (iterable: AnyIterable<T>) => AsyncGenerator<R>;
	export function parallelFlatMap<T, R>(concurrency: number, func: (data: T) => R | Promise<R>, iterable: AnyIterable<T>): AsyncGenerator<R>;
	export function parallelMap<T, R>(concurrency: number): {
		(func: (data: T) => R | Promise<R>, iterable: AnyIterable<T>): AsyncIterableIterator<R>;
		(func: (data: T) => R | Promise<R>): (iterable: AnyIterable<T>) => AsyncIterableIterator<R>;
	};
	export function parallelMap<T, R>(concurrency: number, func: (data: T) => R | Promise<R>): (iterable: AnyIterable<T>) => AsyncIterableIterator<R>;
	export function parallelMap<T, R>(concurrency: number, func: (data: T) => R | Promise<R>, iterable: AnyIterable<T>): AsyncIterableIterator<R>;
  /**
   *Combine multiple iterators into a single iterable. Reads one item off of every iterable and yields them as they resolve. This is useful for pulling items out of a collection of iterables as soon as they're available. Errors `iterables` are raised immediately.

  ```ts
  import { parallelMerge } from 'streaming-iterables'
  import { getPokemon, getTransformer } from 'iterable-pokedex'

  // pokemon are much faster to load btw
  const heros = parallelMerge(getPokemon(), getTransformer())
  for await (const hero of heros) {
	console.log(hero)
  }
  // charmander
  // bulbasaur
  // megatron
  // pikachu
  // eevee
  // bumblebee
  // jazz
  ```
   */
  export function parallelMerge<I extends AnyIterable<any>[]>(...iterables: I): AsyncIterable<UnArrayAnyIterable<I>>;
	/**
	 * Calls `firstFn` and then every function in `fns` with the result of the previous function. The final return is the result of the last function in `fns`.

	```ts
	import { pipeline, map, collect } from 'streaming-iterables'
	import { getPokemon } from 'iterable-pokedex'
	const getName = map(pokemon => pokemon.name)

	// equivalent to `await collect(getName(getPokemon()))`
	await pipeline(getPokemon, getName, collect)
	// charmander
	// bulbasaur
	// MissingNo.
	```
	 */
	export function pipeline<T0>(firstFn: () => T0): T0;
	export function pipeline<T0, T1>(a0: () => T0, a1: (a: T0) => T1): T1;
	export function pipeline<T0, T1, T2>(a0: () => T0, a1: (a: T0) => T1, a2: (a: T1) => T2): T2;
	export function pipeline<T0, T1, T2, T3>(a0: () => T0, a1: (a: T0) => T1, a2: (a: T1) => T2, a3: (a: T2) => T3): T3;
	export function pipeline<T0, T1, T2, T3, T4>(a0: () => T0, a1: (a: T0) => T1, a2: (a: T1) => T2, a3: (a: T2) => T3, a4: (a: T3) => T4): T4;
	export function pipeline<T0, T1, T2, T3, T4, T5>(a0: () => T0, a1: (a: T0) => T1, a2: (a: T1) => T2, a3: (a: T2) => T3, a4: (a: T3) => T4, a5: (a: T4) => T5): T5;
	export function pipeline<T0, T1, T2, T3, T4, T5, T6>(a0: () => T0, a1: (a: T0) => T1, a2: (a: T1) => T2, a3: (a: T2) => T3, a4: (a: T3) => T4, a5: (a: T4) => T5, a6: (a: T5) => T6): T6;
	export function pipeline<T0, T1, T2, T3, T4, T5, T6, T7>(a0: () => T0, a1: (a: T0) => T1, a2: (a: T1) => T2, a3: (a: T2) => T3, a4: (a: T3) => T4, a5: (a: T4) => T5, a6: (a: T5) => T6, a7: (a: T6) => T7): T7;
	export function pipeline<T0, T1, T2, T3, T4, T5, T6, T7, T8>(a0: () => T0, a1: (a: T0) => T1, a2: (a: T1) => T2, a3: (a: T2) => T3, a4: (a: T3) => T4, a5: (a: T4) => T5, a6: (a: T5) => T6, a7: (a: T6) => T7, a8: (a: T7) => T8): T8;
	export function pipeline<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(a0: () => T0, a1: (a: T0) => T1, a2: (a: T1) => T2, a3: (a: T2) => T3, a4: (a: T3) => T4, a5: (a: T4) => T5, a6: (a: T5) => T6, a7: (a: T6) => T7, a8: (a: T7) => T8, a9: (a: T8) => T9): T9;
	/**
	 * An async function that takes a reducer function, an initial value and an iterable.

	Reduces an iterable to a value which is the accumulated result of running each value from the iterable thru `func`, where each successive invocation is supplied the return value of the previous. Errors are immediate raised.
	 */
	export function reduce<T, B>(func: (acc: B, value: T) => B): {
		(start?: B): (iterable: AnyIterable<T>) => Promise<B>;
		(start: B | undefined, iterable: AnyIterable<T>): Promise<B>;
	};
	export function reduce<T, B>(func: (acc: B, value: T) => B, start: B): (iterable: AnyIterable<T>) => Promise<B>;
	export function reduce<T, B>(func: (acc: B, value: T) => B, start: B, iterable: AnyIterable<T>): Promise<B>;
	export type CurriedTakeResult = <T, M extends AnyIterable<T>>(curriedIterable: M) => UnwrapAnyIterable<M>;
	/**
	 * Returns a new iterator that reads a specific number of items from `iterable`. When used with generators it advances the generator, when used with arrays it gets a new iterator and starts from the beginning.

	```ts
	import { pipeline, take, collect } from 'streaming-iterables'
	import { getPokemon } from 'iterable-pokedex'

	const topFive = await collect(take(5, getPokemon()))
	// first five pokemon
	```
	 */
	export function take(count: number): CurriedTakeResult;
	export function take<T, M extends AnyIterable<T>>(count: number, iterable: M): UnwrapAnyIterable<M>;
	export type CurriedTakeLastResult = <T, M extends AnyIterable<T>>(curriedIterable: M) => UnwrapAnyIterable<M>;
	/**
	 * Returns a new iterator that reads a specific number of items from the end of `iterable` once it has completed. When used with generators it advances the generator, when used with arrays it gets a new iterator and starts from the beginning.

	```ts
	import { pipeline, takeLast, collect } from 'streaming-iterables'
	import { getPokemon } from 'iterable-pokedex'

	const bottomFive = await collect(takeLast(5, getPokemon()))
	// last five pokemon
	```
	 */
	export function takeLast(count: number): CurriedTakeLastResult;
	export function takeLast<T, M extends AnyIterable<T>>(count: number, iterable: M): UnwrapAnyIterable<M>;
  /**
   * Takes a `predicate` and a `iterable`, and returns a new async iterator of the same type containing the members of the given iterable until the `predicate` returns false.

  ```ts
  import { takeWhile } from 'streaming-iterables'
  import { getPokemon } from 'iterable-pokedex'

  const firstSlowOnes = takeWhile(pokemon => pokemon.baseStats.speed < 100)

  for await (const pokemon of firstSlowOnes(getPokemon())) {
	console.log(pokemon)
  }
  // Abomasnow
  // Abra
  // Absol
  ```
   */
  export function takeWhile<T, S extends T>(predicate: (data: T) => data is S): <A extends T>(curriedIterable: AnyIterable<A>) => AsyncGenerator<S>;
  export function takeWhile<T>(predicate: (data: T) => boolean | Promise<boolean>): <A>(curriedIterable: AnyIterable<A>) => AsyncGenerator<A>;
  export function takeWhile<T, S extends T>(predicate: (data: T) => data is S, iterable: AnyIterable<T>): AsyncGenerator<S>;
  export function takeWhile<T>(predicate: (data: T) => boolean | Promise<boolean>, iterable: AnyIterable<T>): AsyncGenerator<T>;
	/**
	 * Returns a new iterator that yields the data it consumes, passing the data through to a function. If you provide an async function, the iterator will wait for the promise to resolve before yielding the value. This is useful for logging, or processing information and passing it along.
	 */
	export function tap<T>(func: (data: T) => any): (iterable: AnyIterable<T>) => AsyncGenerator<T>;
	export function tap<T>(func: (data: T) => any, iterable: AnyIterable<T>): AsyncGenerator<T>;
  /**
   * Throttles `iterable` at a rate of `limit` per `interval` without discarding data. Useful for throttling rate limited APIs.

  `limit` can be greater than 0 but less than `Infinity`.
  `interval` can be greater than or equal to 0 but less than `Infinity`.

  ```ts
  import { throttle } from 'streaming-iterables'
  import { getPokemon, trainMonster } from 'iterable-pokedex'

  // load monsters at a maximum rate of 1 per second
  for await (const monster of throttle(1, 1000, getPokemon())) {
	await trainMonster(monster)
  }
  ```
   */
  export function throttle<T>(limit: number, interval: number): (iterable: AnyIterable<T>) => AsyncGenerator<T>;
  export function throttle<T>(limit: number, interval: number, iterable: AnyIterable<T>): AsyncGenerator<T>;
  export interface TimeConfig {
	  progress?: (delta: [number, number], total: [number, number]) => any;
	  total?: (time: [number, number]) => any;
  }
  export type CurriedTimeResult = <T, M extends AnyIterable<T>>(curriedIterable: M) => UnwrapAnyIterable<M>;
  /**
   * Returns a new iterator that yields the data it consumes and calls the `progress` and `total` callbacks with the [`hrtime`](https://nodejs.org/api/process.html#process_process_hrtime_time) it took for `iterable` to provide a value when `.next()` was called on it. That is to say, the time returned is the time this iterator spent waiting for data, not the time it took to finish being read. The `hrtime` tuple looks like `[seconds, nanoseconds]`.

  ```ts
  import { consume, transform, time } from 'streaming-iterables'
  import got from 'got'

  const urls = ['https://http.cat/200', 'https://http.cat/201', 'https://http.cat/202']
  const download = transform(1000, got)
  const timer = time({
	total: total => console.log(`Spent ${total[0]} seconds and ${total[1]}ns downloading cats`),
  })
  // download all of these at the same time
  for await (page of timer(download(urls))) {
	console.log(page)
  }
  ```
   */
  export function time(config?: TimeConfig): CurriedTimeResult;
  export function time<T, M extends AnyIterable<T>>(config: TimeConfig, iterable: M): UnwrapAnyIterable<M>;
  /**
   * Map a function or async function over all the values of an iterable. Order is determined by when `func` resolves. And it will run up to `concurrency` async `func` operations at once. If you care about order see [`parallelMap()`](#parallelmap). Errors from the source `iterable` are raised after all transformed values are yielded. Errors from `func` are raised after all previously transformed values are yielded.

  `concurrency` can be between 1 and `Infinity`.

  ```ts
  import { consume, transform } from 'streaming-iterables'
  import got from 'got'

  const urls = ['https://http.cat/200', 'https://http.cat/201', 'https://http.cat/202']
  const download = transform(1000, got)

  // download all of these at the same time
  for await (page of download(urls)) {
	console.log(page)
  }
  ```
   */
  export function transform(concurrency: number): {
	  <T, R>(func: (data: T) => R | Promise<R>, iterable: AnyIterable<T>): AsyncIterableIterator<R>;
	  <T, R>(func: (data: T) => R | Promise<R>): (iterable: AnyIterable<T>) => AsyncIterableIterator<R>;
  };
  export function transform<T, R>(concurrency: number, func: (data: T) => R | Promise<R>): (iterable: AnyIterable<T>) => AsyncIterableIterator<R>;
  export function transform<T, R>(concurrency: number, func: (data: T) => R | Promise<R>, iterable: AnyIterable<T>): AsyncIterableIterator<R>;
	export interface WritableStreamish {
		once: any;
		write: any;
		removeListener: any;
	}
	/**
	 * Writes the `iterable` to the stream respecting the stream back pressure. Resolves when the iterable is exhausted, rejects if the stream errors during calls to `write()` or if there are `error` events during the write.

	As it is when working with streams there are a few caveats;

	- It is possible for the stream to error after `writeToStream()` has finished writing due to internal buffering and other concerns, so always handle errors on the stream as well.
	- `writeToStream()` doesn't close the stream like `stream.pipe()` might. This is done so you can write to the stream multiple times. You can call `stream.write(null)` or any stream specific end function if you are done with the stream.

	```ts
	import { pipeline, map, writeToStream } from 'streaming-iterables'
	import { getPokemon } from 'iterable-pokedex'
	import { createWriteStream } from 'fs'

	const file = createWriteStream('pokemon.ndjson')
	const serialize = map(pokemon => `${JSON.stringify(pokemon)}\n`)
	await pipeline(getPokemon, serialize, writeToStream(file))
	file.end() // close the stream
	// now all the pokemon are written to the file!
	```
	 */
	export function writeToStream(stream: WritableStreamish): (iterable: AnyIterable<any>) => Promise<void>;
	export function writeToStream(stream: WritableStreamish, iterable: AnyIterable<any>): Promise<void>;
}

//# sourceMappingURL=index.d.mts.map